# 应用系统体系架构

$$
Wang \ Haotian
$$

 ## 10.21 Security

微服务本身不在乎请求从哪里过来的，通过GateWay隔离之后请求没有差异

### Kerberos协议

交大财务调用认证中心，认证中心有两个功能：

1. 认证：你是谁（AS）
2. 授权：你能干什么（TGS）Ticker Granting Server



认证授权部署在同一个服务器上，只做单点认证



Kerbos协议的流程（PPT security第62张的图）

1. 用户想要访问交大财务，现在有一个认证中心的服务器
2. 用户在客户端输入UserId和Pwd
3. UserId发送给AS，Pwd留在本地经过hash产生一个key_user
4. 服务器段根据UserId找到一个user，经过相同的hash算法产生一个key_as
5. key不能在网络上传输的，若AS用key_as加密一个东西（session key，一段时间内有效），user可以拿自己的key_user解密，说明密码对了
6. AS认证之后要进行授权，需要和TGS交互，不能明文交互。AS产生一个session key，通过刚才AS生成的key进行加密，用户拿到session key之后和TGS交互，但是是否相互信任？看下变的流程
7. TGS用TGS的pub_key加密一个session key产生message_b
8. user不能解开message_b，则原封不动传回去，把session key和message_b发回去
9. session key用TGS_pubkey加密之后产生message_c，把UserId和timestamp用session key加密之后产生message_d
10. TGS拿自己的private key解密得到session key，再用session key解密message_d得到信息，知道你在什么时候想要访问
11. 接着TGS进入TGS的数据库查权限信息，有权限才接着进行下一步
12. TGS会生成一个新的key，用于user和交大财务交互
13. TGS用session key加密上边说的user和交大财务交互的key，称message_f，传给user，user就可以用session key解开然后拿到key
14. TGS生成message_e，用交大财务的pub_key加密user和交大财务交互的key，同时附带user client的IP等信息
15. user解密message_f之后，没有交大财务的private key，所以message_e解不开，把message_e原封不动的发回来，交大财务解开之后能拿到client的信息和密钥
16. 用户再发给交大财务client一个message_g，包含client信息，用user和交大财务交互的key加密。交大财务已经有了这个key，因此可以拿到信息
17. 由于TGS是用交大财务的pub_key加密的，所以这个肯定是一个真的网站，不是一个钓鱼网站
18. 交大财务用user和交大财务交互的key加密每次user发来的时间戳+1，称为message_h，client可以检查这个时间戳对不对，以验证交大财务server对不对。



为什么叫单点认证？

AS认证只做一次



局限性：

多跑几个AS和TGS分布式实例，不然就裂开



Kerberos三头狗：

Client、AS/TGS、Service Server相互制约

### 安全

常见攻击手段：

- 跨站脚本攻击：比如一个文本输入框里边输入脚本
- 注入式攻击：密码框输入必定为真的sql脚本
- 分布式拒绝服务攻击（DDOS）：脚本同时动作，发大量请求搞坏服务器



抵御用户的跨站脚本攻击：

1. 把脚本的符号转义掉
2. 富文本编辑器，当文本展示，不当脚本运行

防止注入式攻击：

1. 不要用statement拼sql字符串方式进行JDBC的访问

防止分布式拒绝服务攻击：

1. 同一个IP多少时间内限定访问（但是不同机器就不行了）
2. 做好访问检测



安全的手段：

1. 密文存储
2. 链路加密
3. 维护数据完整性（hash，checksum）
4. 代码有限暴露（尽量所有都是private），封装接口，多个接口合为一个
5. 配置防火墙
6. 入侵检测系统（抓所有的包进行检测）
7. 恢复，打ckpt
8. 日志工具



## 10.25 MySQL Opt

**首先记住一点，数据库的东西在硬盘上存，访问时一定要load到memory，内存比硬盘小，且存在数据不一致，这是一切复杂性的根源**



索引，数据库结构，表的结构，字段设置等

OLAP在线分析处理，列存比较合适

OLTP行存比较合适



### 索引

索引建树的类型

- 索引优化：B+树

- 地理位置索引：R-tree，空间索引是一个地理位置的值，经纬度、海拔、投影值等等很多信息

- MEMORY table支持哈希索引（hash会占用空间）

- InnoDB反向索引实现搜索引擎



索引的注意事项

- 多列索引的排序很重要

- 在查找时，索引文件load到内存里，再内存中搜索，如果索引文件很大，还得把当前这一页换出去，会有额外空间、时间的开销

- 数据量很小的时候建索引，效果提升不明显

- 索引太长，可以做前缀索引。

- 在批量操作，几乎操作所有数据时，索引没有太大意义

- InnoDB在disk上存数据时是按照主键索引的顺序存储的

- 主键要保证绝对唯一，如果是多列联合主键，会增加复杂性



关于全局唯一标识符：

在服务器集群时，可以用全局唯一标识符例如UUID，防止自增主键的重复，UUID是32位16进制数，一共16字节。但是UUID占用空间比较大，而且不能知道插入的先后顺序，若需要时间信息，需要加入额外时间戳。



关于外键：

1. 给不常用的列可以进行分表，外键关联，便于每次向内存加载更多数据，每次不需要从硬盘加载大量数据。否则对常用列的操作性能会降低。
2. 主键要尽量简单，会用其他表的主键当外键



关于前缀索引：

MySQL会对数据做压缩，根据存储方式的不同，前缀索引的长度可以不同



关于多列复合索引：

1. 最多支持16个列，没什么特别限制
2. 查询时匹配的顺序时建索引时的顺序，跳过第一列直接搜索第二列，索引就废了
3. JPA使用数据库的速度可能没那么高，JPA翻译的sql语句可能和预想的不同



关于Hash索引：

不能做范围查找，但是单个查找非常快，order by是不行的



关于索引顺序：

- B+树索引，默认升序，也可以设置为倒序
- 在进行Order By操作时，如果和索引的顺序是相同的，就不需要排序，节省一点时间



### 数据库设计

数据尺寸：

- 数据量尽量小一点=>数据压缩
- 表的列
- 行的格式
- 索引
- Join操作
- 范式化（衡量数据的冗余度，范式化越高数据冗余越小，但是性能可能会变差，因为外键操作特别多，join操作也很多）



表的列：

- 适合它的最小类型
- 尽量不让列为null，可能的话生成not null，null不利于索引，同时占用额外空间，还不利于编程



行结构：

- 可以对行进行一点压缩/Compact（Compact不一定要用压缩算法去压缩，而是一种Compact的表示，在时序数据库中也有体现）



索引：

- 主键索引越短越好，因为外键要存
- 组合索引比多个单独索引要好，因为组合索引是一整个！插入操作不用调整很多个树
- 总的索引越少越好，否则增加插入开销



Join：

- 拆表做join，减少冗余



范式化：

- 去冗余
- 数据同步问题



## 10.28 MySQL Opt

### 数据类型选择：

- 能用数字，不用字符串
- 文本内容很多，不如存成Text或Blob
- 行的尺寸有限制，小于8k可以用varchar，否则一定要用text或者blob，因为一页16k（假设是16k），带上其他数据之后，一行可能存不下
- 主键选择，当一行数据很多时，UUID的空间占用是可以接受的，但是UUID之间无法比较先后顺序
- blob可以设置懒加载，有关blob的表可以专门设置一台机器或者硬盘，和其他经常存取的数据区分开
- blob的比较可以，可以比较摘要，长字符串比较效率很低



### MySQL的设置相关

- table open cache

- 建表、建库的数量和文件系统有关，但是同时打开的表的数量与cache有关，超出上限会告诉你打开表的数量达到上限，暂时不能打开
- 打开的表是在后台统计的，通常比想象的多
- Tomcat启动时会创建数据连接池，MySQL为了使外部连接看起来统一，会为每个连接打开一张表，比如有四个并发会话连接，都打开book table时，就会打开四张表
- MySQL可以设置最大连接数，最大打开表的数量。不能开太多，会占用内存，提升复杂性
- 表只有在evict cache或者flush时才会被认为关闭，类似于内存页的换进换出
- 内存满了会换出最近最少使用的表（替换策略可以换）
- 而在流量很大时，可能会突破内存限制，用完之后立刻关掉（比如，双十一时最近最少使用的表也只是在100ms以内，evict掉很不合理）
- 当Union时，在内存中建一张临时表进行两张表的合并，合并之后在放到disk，这也是**打开表数量超出预想的值**的原因之一
- 表的尺寸不能太大，收到文件系统文件大小的限制
- 表尺寸过大，可以分表，逻辑上可以partition，或者物理上把文件数据分开放在分布式文件系统中
- MySQL列数量有上限
- 行的尺寸也有限制，65535 bytes = 64k，但也不一定，每行的尺寸必须小于页尺寸的一半上限65535是设置page size=128k的情况
- varchar有2byte表示占用长度，nullable需要额外部分尺寸表示是否为空，这两种可能导致行尺寸超出容量限制



### InnoDB

- Optimize storage layout，类似文件碎片整理，还能增加局部性
- 事务AutoCommit，可以多个写操作放在一个事务，关掉AutoCommit，不必每次flush
- long running tx的roll back，部分已经落盘，回滚有额外开销
- long running tx应该拆分成小的tx
- Cache放大一些
- 当tx里边全部是select，MySQL会进行优化（开启只读事务，隔离等级不一样，no-locking select statement）
- rollback要redo、undo，buffer开的大，可以记录操作结果，恢复很容易，比记录操作容易



导入大量数据：

- 关掉AutoCommit

- data loading有大量有insert，若开启AutoCommit，每次都要flush，开销大

- 唯一索引约束插入时会检查唯一性，关掉AutoCommit，会load在内存，内存中检查唯一性比硬盘检查更快
- 使用多行插入
- 整数递增主键间隔设置为2，多线程插入防止冲突



优化Query：

- 主键默认做索引，不要指定太多、太长的列
- 经常访问的列，建其他索引，而且是复合索引而不是多个单独索引
- 尽量声明not null



优化Disk I/O

- 内存不够必然在内存和硬盘换进换出，CPU占用率就高；CPU不忙时，没有频繁的换进换出，那这是怀疑Disk I/O时瓶颈
- 解决方案之一是扩大内存
- 还可以优化flush策略，减少flush
- 还可以指定脏页超过阈值就flush
- DMA直接硬盘访问，跳过内存
- 换硬盘！整一个非旋转性的（比如SSD）！
- 随机读取用SSD很快，而HDD就不太行，但是顺序读取时SSD和HDD性能其实差不多的。HDD保存数据时间比SSD更长。
- 当有500G的SSD和2TB的HDD，fusion storage融合存储，设计一些维度，把不同访问模式的数据放在不同的存储介质上



预抓取Read ahead：

- 缓存在从硬盘读一个表时，会把某一行数据所在的一小块load到缓存
- 后边也有可能接着在下一次读取，这个想法时make sense的
- 因此会预抓取，把下边的也读进来
- 不能一次预抓取太多了，要控制预抓取的数量，因为预抓取是基于判断的，猜错一次开销很大
- 预抓取的策略可以优化



删数据：

truncate table而不是delete，truncate直接抹除

